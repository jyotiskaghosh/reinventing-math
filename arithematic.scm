(define (accumulate op initial sequence)
	(if (null? sequence)
		initial
		(op (car sequence)
		(accumulate op initial (cdr sequence)))))

(define (check-args? x y mod) 
	(define (number? n mod) (and (>= n 0) (< n mod)))
	(and (number? x mod) (number? y mod)))

(define (valid-mod? mod) (and (integer? mod) (>= mod 0)))

(define invalid-args "Invalid arguments")
(define invalid-mod "Invalid modulo")

(define (addition mod)
	(define (add x y) 
		(if (check-args? x y mod) 
			(let ((sum (+ x y))) (if (>= sum mod) (- sum mod) sum))
			(error invalid-args)))
	(if (valid-mod? mod) 
		(lambda (x y . z) (add (add x y) (accumulate add 0 z)))
		(error Invalid-mod)))
	
(define (subtraction mod)
	(define (sub x y)
		(if (check-args? x y mod) 
			(let ((dif (- x y))) (if (< dif 0) (+ dif mod) dif))
			(error invalid-args)))
	(if (valid-mod? mod)
		(lambda (x y . z) (sub (sub x y) (accumulate sub 0 z)))
		(error Invalid-mod)))

(define (multiplication mod)
	(define (mul x y)
		(define (mul x y)
			(if (= y 0) 0 ((addition mod) x (mul x (- y 1)))))
		(cond ((not (check-args? x y mod)) (error invalid-args))
			  ((and (= x 0) (= y 0)) (random mod))
			  (else ((lambda (x y) (if (= y 0) 0 (/ x y))) 
			         (mul (numerator x) (numerator y)) 
			         (mul (denominator x) (denominator y))))))
	(if (valid-mod? mod) 
		(lambda (x y . z) (mul (mul x y) (accumulate mul 1 z)))
		(error Invalid-mod)))

(define (division mod)
	(define (div x y)
		(cond ((not (check-args? x y mod)) (error invalid-args))
			  ((= y 0) 0)
			  (else ((multiplication mod) x (/ 1 y)))))
	(if (valid-mod? mod)
		(lambda (x y . z) (div (div x y) (accumulate div 1 z)))
		(error Invalid-mod)))
